#+TITLE: Justinlime's Emacs
#+AUTHOR: justinlime
#+DESCRIPTION: Justinlime's Emacs
#+PROPERTY: header-args :tangle yes
#+STARTUP: showeverything, inlineimages
      
* TABLE OF CONTENTS :TOC_4:
- [[#general][General]]
  - [[#late-init][Late Init]]
    - [[#package-manger][Package Manger]]
    - [[#use-package][Use Package]]
  - [[#preferences][Preferences]]
    - [[#littering][Littering]]
      - [[#buffer-litter][Buffer Litter]]
      - [[#file-litter][File litter]]
    - [[#gui][GUI]]
    - [[#scrolling][Scrolling]]
    - [[#fonts][Fonts]]
    - [[#misc][Misc]]
  - [[#custom-functions][Custom Functions]]
    - [[#toggle-term][Toggle-Term]]
    - [[#misc-1][Misc]]
- [[#configurations][Configurations]]
  - [[#keybinds][Keybinds]]
    - [[#generalel][General.el]]
    - [[#evil][Evil]]
      - [[#evil-mode][Evil Mode]]
      - [[#evil-collection][Evil Collection]]
    - [[#keychord][Keychord]]
    - [[#which-key][Which Key]]
  - [[#tramp][Tramp]]
  - [[#dired][Dired]]
    - [[#diredfl][Diredfl]]
    - [[#dired-ranger][Dired Ranger]]
  - [[#eglot][Eglot]]
  - [[#erc][ERC]]
  - [[#term][Term]]
  - [[#org][Org]]
    - [[#org-toc][Org Toc]]
    - [[#org-modern][Org Modern]]
    - [[#org-roam][Org Roam]]
  - [[#minibuffer][Minibuffer]]
    - [[#marginalia][Marginalia]]
    - [[#vertico][Vertico]]
  - [[#finding][Finding]]
    - [[#zoxide][Zoxide]]
    - [[#affe][Affe]]
    - [[#consult][Consult]]
  - [[#completion][Completion]]
    - [[#corfu][Corfu]]
      - [[#corfu-terminal][Corfu Terminal]]
    - [[#cape][Cape]]
    - [[#orderless][Orderless]]
    - [[#yasnippet][Yasnippet]]
      - [[#yasnippet-snippets][Yasnippet Snippets]]
      - [[#yasnipped-capf][Yasnipped Capf]]
  - [[#git][Git]]
    - [[#magit][Magit]]
    - [[#diff-hl][Diff-hl]]
  - [[#misc-2][Misc]]
    - [[#dashboard][Dashboard]]
    - [[#perspective][Perspective]]
    - [[#undo-tree][Undo Tree]]
    - [[#direnv][Direnv]]
    - [[#sideline][Sideline]]
      - [[#sideline-flymake][Sideline Flymake]]
    - [[#sudo-edit][Sudo Edit]]
  - [[#programming-modes][Programming Modes]]
    - [[#python-mode][Python Mode]]
    - [[#javascript-mode][Javascript Mode]]
    - [[#typescript-mode][TypeScript Mode]]
    - [[#vue-mode][Vue Mode]]
    - [[#go-mode][Go Mode]]
    - [[#nix-mode][Nix Mode]]
    - [[#lua-mode][Lua Mode]]
    - [[#elixir-mode][Elixir Mode]]
    - [[#rust-mode][Rust Mode]]
    - [[#powershell-mode][PowerShell Mode]]
    - [[#markdown-mode][Markdown Mode]]
  - [[#style][Style]]
    - [[#themes][Themes]]
    - [[#modeline][Modeline]]
    - [[#nerd-icons][Nerd Icons]]
      - [[#nerd-icons-dired][Nerd Icons Dired]]
      - [[#nerd-icons-dired-1][Nerd Icons Dired]]
    - [[#highlight-todo][Highlight TODO]]
    - [[#rainbow-mode][Rainbow Mode]]
    - [[#rainbow-delimiters][Rainbow Delimiters]]
    - [[#treesitter][Treesitter]]

* General
** Late Init
#+begin_src emacs-lisp
;; revert inflated GC defined in early init to avoid GC pauses while editing
(add-hook 'after-init-hook #'(lambda ()
    (setq file-name-handler-alist file-name-handler-alist-original)
    (makunbound 'file-name-handler-alist-original)))
;; Revert again just in case if out of focus (doesnt work for terminal emacs)
;; and use the chance to collect garbage
(add-hook 'focus-out-hook #'(lambda ()
  (setq gc-cons-threshold (* 1024 1024 16))
  (garbage-collect)))
;; Revert after 5 seconds of being idle as an additonal precaution
(run-with-idle-timer 5 nil
  (lambda ()
    (setq gc-cons-threshold (* 1024 1024 16))))
#+end_src 
*** Package Manger
#+begin_src emacs-lisp 
(require 'package) ; load the package manager
(setq package-check-signature nil) ; override signature errors
;; add package archives to package manager
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/") t)
(package-initialize) ; exactly what it sounds like 
;; pull archvies and prevent warning messages only on very first startup
(unless package-archive-contents
  (progn
    (setq warning-minimum-level :emergency) 
    (package-refresh-contents)))
#+end_src
*** Use Package
#+begin_src emacs-lisp 
;; install use-package if it doesn't exist yet
(unless (package-installed-p 'use-package) 
  (package-install 'use-package))          
(require 'use-package) ; load use-package
;; Make use-package uses package.el, prevents having to use :ensure t on everything
(setq use-package-always-ensure t) 
#+end_src
** Preferences 
*** Littering
**** Buffer Litter
#+begin_src emacs-lisp
;; Kill *Help* after :q'ing, and kill magit buffers when quitting them
(advice-add #'evil-quit :after #'(lambda(&rest r)
  (let ((buf (get-buffer "*Help*")))
    (if (eq buf nil) nil
      (kill-buffer buf))
    (dolist (b (magit-mode-get-buffers))
        (kill-buffer b)))))

;; ;; Disables all startup warnings, and kills message buffer, comment this out when debugging
(setq warning-minimum-level :emergency)
(setq-default message-log-max nil)
(add-hook 'emacs-startup-hook #'(lambda() ;Kills the warning buffer for even emergency messages
  (kill-buffer (get-buffer "*Messages*"))))
#+end_src
**** File litter
#+begin_src emacs-lisp
(setq make-backup-files nil ; stop creating ~ files
      auto-save-default nil ; Disable autosave # files
      create-lockfiles nil) ; Disable .# files
#+end_src
*** GUI
#+begin_src emacs-lisp
(setq use-dialog-box nil) ; No dialog box
(menu-bar-mode -1) ;Disable menu
(tool-bar-mode -1) ;Disable toolbar
(scroll-bar-mode -1) ;Disable scroll bar
;; Transparency
(set-frame-parameter nil 'alpha-background 100) ; For current frame
(add-to-list 'default-frame-alist '(alpha-background . 100)) ; For all new frames henceforth
#+end_src
*** Scrolling
#+begin_src emacs-lisp 
(setq-default pixel-scroll-precision-mode t
      mouse-wheel-scroll-amount '(1 ((shift) . 1)) ;; one line at a time
      mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
      mouse-wheel-follow-mouse 't ;; scroll window under mouse
      scroll-margin 1
      scroll-conservatively 0
      scroll-up-aggressively 0.01
      scroll-down-aggressively 0.01)
(unless (display-graphic-p) 
  (setq scroll-conservatively 101))
#+end_src
*** Fonts
#+begin_src emacs-lisp
(set-face-attribute 'default nil
  :font "RobotoMono Nerd Font"
  :height 120
  :weight 'medium)
(set-face-attribute 'variable-pitch nil
  :font "Roboto"
  :height 120
  :weight 'medium)
(set-face-attribute 'fixed-pitch nil
  :font "RobotoMono Nerd Font"
  :height 120
  :weight 'medium)
(setq-default line-spacing 0.12)
(set-language-environment "UTF-8")
#+end_src
*** Misc
#+begin_src emacs-lisp
;; Enable mouse in term-mode
(unless (display-graphic-p)
  (xterm-mouse-mode 1))
(setq blink-cursor-mode nil ; Exactly what is sounds like
      use-short-answers t ; Set y or n instead of yes or no for questions
      display-line-numbers-type 'relative ; Realive line numbers
      frame-resize-pixelwise t) ; Better frame resizing
(setq-default tab-width 2 ; self explanitory
              indent-tabs-mode nil ; use spaces not tabs
              truncate-lines t) ;Allow truncated lines
(electric-pair-mode 1) ; Auto closing pairs like () and {}
(save-place-mode) ; Save cursor position in buffer on reopen
(global-hl-line-mode) ; Highlight the current line
(electric-indent-mode t) ; Auto Indent
(global-display-line-numbers-mode 1) ;Display line numbers
#+end_src
** Custom Functions
*** Toggle-Term
#+begin_src emacs-lisp
;; This is sphagetti code but I dont care
(let ((init-term "*toggle-term-main*"))
  (defvar jl/active-toggle-term `(("main" ,init-term)) "The most recently used toggle term")
  (defvar jl/current-toggles `(("main" (,init-term))) "List of the current toggle terms"))

(defun jl/toggle-term (&optional name command)
  "Toggle a terminal window with $SHELL, and make it the active term

  If NAME is not provided, prompt to user for one. Closes any other toggle-terms
  currently open that aren't NAME

  NAME can be in the *name* format or just name, but the buffers' name will always output to *name*

  Integrated with perspective.el

  If COMMAND is set, the created terminal will execute the command using your shell's -c flag"
  (interactive)
  ;; Create a key and default value for the alist if it doesnt exist for the perspective 
  (if (eq (assoc (persp-current-name) jl/current-toggles) nil)
    (progn
      (let ((wrapped-name (format "*toggle-term-%s*" (persp-current-name))))
        (add-to-list 'jl/current-toggles `(,(persp-current-name) (,wrapped-name)))
        (setq name wrapped-name)
        (setq jl/active-toggle-term (cons `(,(persp-current-name) ,wrapped-name) jl/active-toggle-term)))))
  (let* (
    (current-toggles-persp (car (cdr (assoc (persp-current-name) jl/current-toggles))))
    ;; Wrapping and unwrapping to force a *name* naming scheme
    (name (if name name (completing-read "Toggle-Term: " current-toggles-persp)))
    (unwrapped-name (replace-regexp-in-string "\\*" "" name))
    (wrapped-name (format "*%s*" unwrapped-name))) 
      ;; Check if another toggle-term is active
      (dolist (c current-toggles-persp)
        (if (string-equal c wrapped-name)
          nil
          (let ((w (get-buffer-window c)))
            (if w (delete-window w)))))
        ;; Toggle the term
        (let (
          (height (window-total-height))
          (window (get-buffer-window wrapped-name)))
            (if window (delete-window window)
                ;; Creates a window below the current window at 22% of the windows height
                (select-window (split-root-window-below (round (* height 0.78))))
                ;; If command is provided, start the term using the shells -c flag
                (if (eq command nil)
                  (make-term unwrapped-name (getenv "SHELL")) ; The make-term function automatically wraps *'s around the name given, hence the unwrapped name being used.
                  (make-term unwrapped-name (getenv "SHELL") nil "-c" command)) 
                ;; Sets the active terminal for the current perspective in the alist
                (let ((key (assoc (persp-current-name) jl/active-toggle-term)))
                  (if key
                    (setcdr key `(,wrapped-name))
                    (setq jl/active-toggle-term (cons `(,(persp-current-name) ,wrapped-name) jl/active-toggle-term))))
                ;; Adds the terminal to the current-toggles alist if its not already included
                (if (member wrapped-name current-toggles-persp) nil
                  (let* ((key (assoc (persp-current-name) jl/current-toggles))
                         (orig-list (car(cdr key))))
                    (if key
                      (progn
                        (add-to-list 'orig-list wrapped-name)
                        (setcdr key `(,orig-list)))
                      (add-to-list 'jl/current-toggles `(,(persp-current-name) (,wrapped-name))))))
                ;; Switch to the buffer and enter insert mode
                (switch-to-buffer wrapped-name)
                (evil-insert 1)))))

(defun jl/toggle-active-term ()
  "Toggle the most recently used toggle-term"
  (interactive)
  (jl/toggle-term (car (cdr (assoc (persp-current-name) jl/active-toggle-term)))))
#+end_src
*** Misc
#+begin_src emacs-lisp
(defun jl/ssh (host formatter)
  (persp-switch host)
  (advice-add #'read-passwd :around #'jl/capture-password)
  (let ((format-host (format formatter host host)))
    (find-file format-host)
    (jl/toggle-term host (format "ssh %s" host)))
  ;; Poll the buffer every .2 seconds for the prompt
  (setq jl/password-timer (run-at-time .20 .20 #'(lambda()
  (if (string-match "Enter Passphrase for key" (buffer-string))
    (progn
      (jl/str-to-input jl/pass)
      (execute-kbd-macro (kbd "RET"))
      (setq jl/pass nil)
      (cancel-timer jl/password-timer)
      (advice-remove #'read-passwd #'jl/capture-password)))))))
(defun jl/ssh-root (host)
  "SSH with sudo privledges using a host from .ssh/config"
  (interactive "sEnter host: ")
  (jl/ssh host "/ssh:%s|sudo:%s:/"))
(defun jl/ssh-user (host)
  "SSH using a host from .ssh/config"
  (interactive "sEnter host: ")
  (jl/ssh host "/ssh:%s:~"))
(defun jl/samba (host)
  (interactive "sEnter user@ip: ")
  (find-file (format "/smb:%s:" host)))

(defvar jl/pass nil)
(defun jl/capture-password (orig-func &rest args)
  "Capture the password temporarily to send to send somewhere
   Probably pretty insecure but I dont really care"

  (let ((pass (apply orig-func args)))
    ;; only capture if jl/pass is not active
    (if (eq jl/pass nil)
      (setq jl/pass pass)
      (run-at-time 60 nil #'(lambda()
          ;; clear the pass from memory
          (setq jl/pass nil))))
    ;; always return the original value so the orig-function works like normal
    pass))

(defun jl/str-to-input (str)
  (mapc (lambda (char)
    (execute-kbd-macro (char-to-string char)))
    str))

(defun jl/consult-find-in-dir ()
  "Find a file in a specific directory
   
  Uses Affe if working with local files, and Consult for remote files"
  (interactive)
  (let ((dir (file-name-directory (read-file-name "Find in directory: "))))
    (if (string-prefix-p "/ssh:" default-directory)
      (consult-find dir)
      (affe-find dir))))
(defun jl/consult-find-in-current ()
  "Find a file in the project's directory

  Sets the root of the search to the folders' .git parent path if present

  Uses Affe if working with local files, and Consult for remote files"
  (interactive)
  (let ((dir (magit-toplevel default-directory)))
    (if (string-prefix-p "/ssh:" default-directory)
      (if dir
        (consult-find dir)
        (consult-find))
      (if dir
        (affe-find dir)
        (affe-find)))))

(defun jl/consult-grep-in-dir ()
  "Find a word in a specified project/folder

  Uses Ripgrep if working with local files, and Grep for remote files"
  (interactive)
  (let ((dir (file-name-directory (read-file-name "Find in directory: "))))
    (if (string-prefix-p "/ssh:" default-directory)
      (consult-grep dir)
      (consult-ripgrep dir))))

(defun jl/consult-grep-in-current ()
  "Find a word in the current project/folder

  Sets the root of the search to the folders' .git parent path if present

  Uses Ripgrep if working with local files, and Grep for remote files"
  (interactive)
  (let ((dir (magit-toplevel default-directory)))
    (if dir
      (if (string-prefix-p "/ssh:" default-directory)
        (consult-grep dir)
        (consult-ripgrep dir))
      (if (string-prefix-p "/ssh:" default-directory)
        (consult-grep)
        (consult-ripgrep)))))

(defun jl/random-quote ()
  "Generate a random quote for dashboard"
  (interactive)
  (let ((ops '(
    "Hello World!"
    "Whopper Whopper Whopper Whopper Junior Double Triple Whopper"
    "sudo systemctl stop justinlime"
    "sudo systemctl start justinlime"
    "sudo systemctl restart justinlime"
    "White Monster"
    "https://stinkboys.com"
    "Stink Boys Inc. ©"
    "/home/justinlime/.config"
    "No emacs???"))) (nth (random (length ops)) ops)))
(defun jl/random-icon ()
  "Generate a random image for dashboard"
  (interactive)
  (let* ((icons-dir (expand-file-name "icons/" user-emacs-directory))
        (ops (directory-files icons-dir))
        (ops (delete "." ops))
        (ops (delete ".." ops))
        (file (nth (random (length ops)) ops)))
          (expand-file-name file icons-dir)))
(defun jl/dired-open ()
  "Open path in the same buffer if a file, and a new one if a directory in dired"
  (interactive)
  (if (file-directory-p (dired-get-file-for-visit))
    (dired-find-alternate-file)
    (dired-find-file)))
#+end_src
* Configurations
** Keybinds
*** General.el
#+begin_src emacs-lisp
(use-package general
  :config
    ;; set up 'SPC' as the global leader key
    (general-create-definer leader
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC" ;; set leader
      :global-prefix "M-SPC") ;; access leader in insert mode
    (leader
      "w" '(:ignore t :wk "Window Navigation")
      "w h" '(evil-window-left :wk "Move left to window")
      "w j" '(evil-window-down :wk "Move down to window")
      "w k" '(evil-window-up :wk "Move up to window")
      "w l" '(evil-window-right :wk "Move right to window")
      "w s" '(evil-window-split :wk "Split window horizontally")
      "w v" '(evil-window-vsplit :wk "Split window vertically"))
    (leader
      "b k" '(kill-this-buffer :wk "Kill this buffer")
      "b r" '(revert-buffer :wk "Reload this buffer"))
    (leader
      "e" '(:ignore t :wk "Evaluate")    
      "e b" '(eval-buffer :wk "Evaluate elisp in buffer")
      "e e" '(eval-expression :wk "Evaluate and elisp expression")
      "e r" '(eval-region :wk "Evaluate selected elisp")) 
    (leader
      "h" '(:ignore t :wk "Help")
      "h f" '(describe-function :wk "Help function")
      "h v" '(describe-variable :wk "Help variable")
      "h m" '(describe-mode :wk "Help mode")
      "h c" '(describe-char :wk "Help character")
      "h k" '(describe-key :wk "Help key/keybind"))
    (leader
      "c r" '(comment-region :wk "Comment selection")
      "c l" '(comment-line :wk "Comment line"))
    (leader
      "t t" '(jl/toggle-active-term :wk "Toggle the active toggle-term")
      "t f" '(jl/toggle-term :wk "Find a toggle-term, or create a new one"))
    (leader
      "f f" '(find-file :wk "Find File"))
    (leader
      "s u" '(jl/ssh-user :wk "SSH as user, using the ssh config file")
      "s r" '(jl/ssh-root :wk "SSH as user with root privledges, using the ssh config file")
      "s m" '(jl/samba :wk "Access an SMB share")))
#+end_src
*** Evil
**** Evil Mode
#+begin_src emacs-lisp
(use-package evil
  :general
    (:states 'insert
      "<tab>" #'tab-to-tab-stop
      "TAB" #'tab-to-tab-stop)
    (:states '(normal insert visual emacs)
      "C-u" #'evil-scroll-up
      "C-d" #'evil-scroll-down)
    (:states '(normal emacs)
      "J" #'shrink-window
      "K" #'enlarge-window
      "H" #'shrink-window-horizontally
      "L" #'enlarge-window-horizontally
      "u" #'undo-tree-undo
      "R" #'undo-tree-redo)
  :init      ;; tweak evil's configuration before loading it
    (setq evil-want-integration t ;; This is optional since it's already set to t by default.
          evil-want-keybinding nil
          evil-vsplit-window-right t
          evil-split-window-below t
          evil-shift-width 4)
    (evil-mode)
  :config
    ;; These hooks may not work if TERM isnt xterm/xterm256
    ;; Let cursor change based on mode when using emacs in the terminal
    (unless (display-graphic-p)
      (defun correct-cursor (&rest r)
        (setq visible-cursor nil) 
        (if (eq evil-state 'insert)
          (send-string-to-terminal "\e[5 q")
          (send-string-to-terminal "\e[2 q")))
      (add-hook 'evil-insert-state-entry-hook #'correct-cursor)
      (add-hook 'evil-normal-state-entry-hook #'correct-cursor)
      (advice-add 'eldoc-documentation-default :after #'correct-cursor) ;;Echo Area
      (advice-add 'eldoc-display-in-buffer :after #'correct-cursor))) ;;Buffer
#+end_src
**** Evil Collection
#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
    (setq evil-collection-mode-list '(magit term help dashboard dired ibuffer tetris))
    (evil-collection-init))
#+end_src
*** Keychord
#+begin_src emacs-lisp
(use-package key-chord
  :init
    (key-chord-mode 1)
  :config
    (setq key-chord-two-keys-delay 1
          key-chord-one-key-delay 1.2
          key-chord-safety-interval-forward 0.1
          key-chord-safety-interval-backward 1)
    (key-chord-define evil-insert-state-map  "jj" 'evil-normal-state))
#+end_src 
*** Which Key
#+begin_src emacs-lisp 
(use-package which-key
  :init
    (which-key-mode 1)
  :config
    (setq which-key-side-window-location 'bottom
      which-key-sort-order #'which-key-key-order-alpha
      which-key-sort-uppercase-first nil
      which-key-add-column-padding 1
      which-key-max-display-columns nil
      which-key-min-display-lines 6
      which-key-side-window-slot -10
      which-key-side-window-max-height 0.25
      which-key-idle-delay 0.8
      which-key-max-description-length 25
      which-key-allow-imprecise-window-fit t
      which-key-separator " → " ))
#+end_src
** Tramp
#+begin_src emacs-lisp
(setq password-cache-expiry nil) ; so tramp doesnt keep prompting for passwords while connected
;; Speeds up tramp allegedly
(with-eval-after-load 'tramp
  (setq tramp-inline-compress-start-size 1000
        tramp-copy-size-limit 10000
        vc-handled-backends '(git)
        tramp-default-method "rcp"
        tramp-use-ssh-controlmaster-options nil
        projectile--mode-line "Projectile"))
#+end_src
** Dired
#+begin_src emacs-lisp
(advice-add #'dired-do-delete :after #'(lambda(&rest r) (dired-unmark-all-marks) (revert-buffer)))
(advice-add #'dired-do-flagged-delete :after #'(lambda(&rest r) (dired-unmark-all-marks) (revert-buffer)))
(general-define-key
  :states 'normal
  :keymaps 'dired-mode-map
  "s" #'dired-hide-details-mode
  "A" #'dired-create-directory
  "W" #'wdired-change-to-wdired-mode
  "RET" #'jl/dired-open)
;; (setq dired-dwim-target t) ; Dired will prompt to copy/move to another dired buffer if its visible
(put 'dired-find-alternate-file 'disabled nil) ;Allow "dired-find-alternate-file to work without a prompt"
(add-hook 'dired-mode-hook #'(lambda ()
  (auto-revert-mode)
  (dired-hide-details-mode)))
(setq dired-listing-switches "-alFh")

(general-define-key
  :states 'normal
  :keymaps 'wdired-mode-map
  "W" #'wdired-finish-edit
  "<escape>" #'wdired-exit)
(setq wdired-allow-to-change-permissions t)
#+end_src
*** Diredfl
#+begin_src emacs-lisp
(use-package diredfl
  :config
    (diredfl-global-mode))
#+end_src
*** Dired Ranger
#+begin_src emacs-lisp
(use-package dired-ranger
  :general
    (:keymaps 'dired-mode-map
     :states '(normal emacs motion)
       "y" #'dired-ranger-copy
       "P" #'dired-ranger-paste
       "M" #'dired-ranger-move)
  :config
    ;; remove marks after an action, and also revert buffer to fix broken icons/formatting after
    ;; moving or pasting
    (advice-add #'dired-ranger-copy :after #'(lambda(&rest r) (dired-unmark-all-marks)))
    (advice-add #'dired-ranger-move :after #'(lambda(&rest r) (dired-unmark-all-marks) (revert-buffer)))
    (advice-add #'dired-ranger-paste :after #'(lambda(&rest r) (dired-unmark-all-marks) (revert-buffer)))
    (setq dired-ranger-copy-ring-size 1)) ;; only keep latest copy in memory
#+end_src
** Eglot
#+begin_src emacs-lisp
;; Override the binary being used on startup
(with-eval-after-load 'eglot
  (add-to-list 'eglot-server-programs
               '((java-ts-mode java-mode) . ("java-language-server")))
  (add-to-list 'eglot-server-programs
               '((nix-ts-mode nix-mode) . ("nixd"))))

(defvar jl/eglot-enabled-langs 
    '(go-ts-mode  
      python-ts-mode
      js-ts-mode
      typescript-ts-mode
      rust-ts-mode
      elixir-ts-mode
      nix-ts-mode
      java-ts-mode
      c-ts-mode
      bash-ts-mode))

(add-hook 'find-file-hook #'(lambda()
    (unless (file-remote-p (buffer-file-name)) 
      (dolist (lang jl/eglot-enabled-langs)
        (if (eq major-mode lang)
          (progn
            
            (eglot-ensure)
            (sideline-mode)))))))
#+end_src
** ERC
#+begin_src emacs-lisp
(add-hook 'erc-mode-hook #'(lambda ()
  (toggle-truncate-lines) ; truncate lines in erc mode
  (persp-add-buffer (current-buffer)) ; fix erc buffers not being listed in buffer menu when using perspective.el
  (display-line-numbers-mode -1)))
#+end_src
** Term
#+begin_src  emacs-lisp
(add-hook 'term-mode-hook #'(lambda()
  (general-define-key
    :states 'insert
    :keymaps 'term-raw-map
    "TAB" #'(lambda() (interactive) (term-send-raw-string "\t")))
  (face-remap-set-base 'default :background "#11111B")
  (face-remap-set-base 'fringe :background "#11111B")
  (hl-line-mode 'toggle)
  (defface term-background
  '((t (:inherit default :background "#11111B")))
  "Some bullshit to fix term-mode text-background"
  :group 'basic-faces)

  (setf (elt ansi-term-color-vector 0) 'term-background)

  (display-line-numbers-mode -1)))
#+end_src
** Org
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
(setq org-startup-with-inline-images t)
(general-define-key
  :states 'normal 
  :keymaps 'org-mode-map
  "RET" #'org-open-at-point
  "<tab>" #'org-cycle
  "TAB" #'org-cycle)


(add-hook 'org-mode-hook #'(lambda ()
  (org-indent-mode)
  (setq-local electric-indent-mode nil)))

;; Scale inline images to the windows size adaptively
;; This lags the shit out of emacs
;; (defun org-image-resize (frame)
;;   (when (derived-mode-p 'org-mode)
;;       (setq org-image-actual-width (round (* (window-pixel-width) 0.5)))
;;       (org-redisplay-inline-images)))

;; (add-hook 'window-size-change-functions 'org-image-resize)
#+end_src
*** Org Toc
#+begin_src emacs-lisp
(use-package toc-org
  :commands toc-org-enable
  :init
    (add-hook 'org-mode-hook 'toc-org-enable)
    (add-hook 'markdown-mode-hook 'toc-org-enable))
#+end_src
*** Org Modern
#+begin_src emacs-lisp
(use-package org-modern
  :init 
    (with-eval-after-load 'org (global-org-modern-mode)))
#+end_src
*** Org Roam
#+begin_src emacs-lisp
(use-package org-roam
  :general
    (leader
      "r" '(:ignore t :wk "Org Roam")
      "r f" '(org-roam-node-find :wk "Find org roam file")
      "r t" '(org-roam-buffer-toggle :wk "Toggle the roam buffer")
      "r c" '(org-capture-finalize :wk "Capture the roam buffer")
      "r i" '(org-roam-node-insert :wk "Insert node link"))
  :custom
    (org-roam-directory (file-truename "~/sync/notes/roam"))
  :config
    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode 1)
    (require 'org-roam-protocol))
#+end_src
** Minibuffer
#+begin_src emacs-lisp
(general-define-key
  :keymaps 'minibuffer-local-map
  "<escape>" #'keyboard-escape-quit)
#+end_src
*** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :init
  (marginalia-mode))
#+end_src
*** Vertico
#+begin_src emacs-lisp
(use-package vertico
  :general
    (:keymaps 'vertico-map
      "RET" #'vertico-directory-enter
      "<tab>" #'vertico-next
      "TAB" #'vertico-next
      "<backspace>" #'vertico-directory-delete-char
      "DEL" #'vertico-directory-delete-char
      "<backtab>" #'vertico-previous)
  :init
    (vertico-mode))
#+end_src

** Finding
*** Zoxide
#+begin_src emacs-lisp
(use-package zoxide
  :general
    (leader
      "f d" '(zoxide-travel :wk "Find directory with Zoxide"))
  :config
    (add-hook 'dired-mode-hook #'zoxide-add))
#+end_src
*** Affe
#+begin_src emacs-lisp
(use-package affe)
#+end_src
*** Consult
#+begin_src emacs-lisp
(use-package consult
  :general
    (leader
      "f r" '(jl/consult-find-in-current :wk "Find file in current dir/project")
      "f R" '(jl/consult-find-in-dir :wk "Find file in specified dir/project")
      "f w" '(jl/consult-grep-in-current :wk "Find word in current dir/project")
      "f W" '(jl/consult-grep-in-dir :wk "Find word in specified dir/project"))
  :config
    (setq consult-find-args "find . -not ( -path '*/.git*' -prune ) -not ( -path '*.git*' -prune )"))
#+end_src
** Completion
*** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :general
    (:keymaps 'corfu-map :states 'insert
      "<tab>" #'corfu-next
      "TAB" #'corfu-next
      "<backtab>" #'corfu-previous) 
  :config
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
    ;; Prevent evil from overriding corfu bindings
    (with-eval-after-load #'corfu
      (advice-add #'corfu--setup :after #'(lambda(&rest r) (evil-normalize-keymaps)))
      (advice-add #'corfu--teardown :after #'(lambda(&rest r) (evil-normalize-keymaps)))
      (evil-make-overriding-map corfu-map))
    (setq corfu-popupinfo-delay 0)
  :custom
    (corfu-auto t)
    (corfu-cycle t)
    (corfu-preselect 'prompt)
    (corfu-auto-delay 0.05)
    (corfu-auto-prefix 2)
  :init
    (corfu-popupinfo-mode)
    (global-corfu-mode)
    (corfu-history-mode))
#+end_src
**** Corfu Terminal
#+begin_src emacs-lisp
(use-package corfu-terminal
  :config
    (unless (display-graphic-p)
      (corfu-terminal-mode 1)))
#+end_src
*** Cape
#+begin_src emacs-lisp
(use-package cape
  :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-elisp-block)
    (add-to-list 'completion-at-point-functions #'cape-keyword))
#+end_src
*** Orderless
#+begin_src emacs-lisp
(use-package orderless
  :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
*** Yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :config
    (setq yas-snippet-dirs `(,(expand-file-name "snips/" user-emacs-directory)))
    (yas-global-mode 1))
#+end_src
**** Yasnippet Snippets
#+begin_src emacs-lisp
(use-package yasnippet-snippets)
#+end_src
**** Yasnipped Capf
#+begin_src emacs-lisp
(use-package yasnippet-capf
  :after cape
  :config
    (setq yasnippet-capf-lookup-by 'name) ;; Prefer the name of the snippet instead
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))
#+end_src
** Git
*** Magit
#+begin_src emacs-lisp
(use-package magit 
  :config
   (leader
    "g s" '(magit-stage-file :wk "Stage Files")
    "g S" '(magit-stage-modified :wk "Stage All Files")
    "g u" '(magit-unstage-file :wk "Unstage Files")
    "g U" '(magit-unstage-all :wk "Unstage All Files")
    "g f" '(magit-fetch :wk "Fetch")
    "g F" '(magit-fetch-all :wk "Fetch")
    "g i" '(magit-init :wk "Init")
    "g l" '(magit-log :wk "Log")
    "g b" '(magit-branch :wk "Branch")
    "g d" '(magit-diff :wk "Diff")
    "g c" '(magit-commit :wk "Commit")
    "g r" '(magit-rebase :wk "Rebase")
    "g R" '(magit-reset :wk "Reset")
    "g p" '(magit-push :wk "Push")
    "g P" '(magit-pull :wk "Pull")
    "g m" '(magit :wk "Magit Menu"))

    (add-hook 'magit-post-stage-hook #'(lambda ()
      (message "Staged"))))
#+end_src
*** Diff-hl
#+begin_src emacs-lisp
(use-package diff-hl 
  :config 
    (add-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)
    (add-hook 'diff-hl-mode-hook #'diff-hl-margin-mode)
    (global-diff-hl-mode))
#+end_src
** Misc
*** Dashboard
#+begin_src emacs-lisp
(use-package dashboard
  :config
    (setq default-directory "~/"
          initial-buffer-choice (lambda() (get-buffer-create "*dashboard*")) 
          dashboard-banner-logo-title (jl/random-quote)
          dashboard-footer-messages `(,(jl/random-quote)))
    (when (display-graphic-p)
      (setq dashboard-startup-banner (jl/random-icon)))
    (dashboard-setup-startup-hook))

(add-hook 'dashboard-mode-hook #'(lambda() (set-cursor-color "#cba6f7")))
(add-hook 'dashboard-mode-hook #'(lambda() (set-face-attribute
 'line-number-current-line nil :foreground "#cba6f7")))
#+end_src
*** Perspective
#+begin_src emacs-lisp
(use-package perspective
  :init
    (setq persp-suppress-no-prefix-key-warning t)
    (setq persp-initial-frame-name "emacs")
    (persp-mode)
  :general
    (leader
      "b f" '(persp-switch-to-buffer* :wk "Find a buffer, or create a new one")
      "b i" '(persp-ibuffer :wk "Buffer Menu (IBuffer)")
      "p f" '(persp-switch :wk "Find perspective, or create new one")
      "p h" '(persp-prev :wk "Previous perspective")
      "p l" '(persp-next :wk "Next perspective")
      "p k" '((lambda () (interactive) (if (yes-or-no-p "Kill the current perspective?")(persp-kill (persp-current-name)))) :wk "Kill the current perspective")
      "p 1" '((lambda () (interactive) (persp-switch-by-number 1)) :wk "Switch to perspective 1")
      "p 2" '((lambda () (interactive) (persp-switch-by-number 2)) :wk "Switch to perspective 2")
      "p 3" '((lambda () (interactive) (persp-switch-by-number 3)) :wk "Switch to perspective 3")
      "p 4" '((lambda () (interactive) (persp-switch-by-number 4)) :wk "Switch to perspective 4")
      "p 5" '((lambda () (interactive) (persp-switch-by-number 5)) :wk "Switch to perspective 5")
      "p 6" '((lambda () (interactive) (persp-switch-by-number 6)) :wk "Switch to perspective 6")
      "p 7" '((lambda () (interactive) (persp-switch-by-number 7)) :wk "Switch to perspective 7")
      "p 8" '((lambda () (interactive) (persp-switch-by-number 8)) :wk "Switch to perspective 8")
      "p 9" '((lambda () (interactive) (persp-switch-by-number 9)) :wk "Switch to perspective 9")
      "p 0" '((lambda () (interactive) (persp-switch-by-number 0)) :wk "Switch to perspective 0"))
  :config
    (setq persp-sort 'created)
    ;; Overriding the function to reverse the sorting order
    (defun persp-names ()
      "Return a list of the names of all perspectives on the `selected-frame'.

    If `persp-sort' is 'name (the default), then return them sorted
    alphabetically. If `persp-sort' is 'access, then return them
    sorted by the last time the perspective was switched to, the
    current perspective being the first. If `persp-sort' is 'created,
    then return them in the order they were created, with the newest
    first."
      (let ((persps (hash-table-values (perspectives-hash))))
        (cond ((eq persp-sort 'created)
                 (mapcar 'persp-name
                   (sort persps (lambda (a b)
                     (time-less-p (persp-created-time a)
                       (persp-created-time b))))))))))
#+end_src
*** Undo Tree
#+begin_src emacs-lisp
(use-package undo-tree
  :config
    (global-undo-tree-mode)
    (setq undo-tree-auto-save-history t)
    (setq undo-tree-history-directory-alist '(("." . "~/.config/emacs/undo"))))
#+end_src
*** Direnv
#+begin_src emacs-lisp
(use-package envrc
  :config
    (envrc-global-mode))
#+end_src
*** Sideline
#+begin_src emacs-lisp
(use-package sideline
  :init
    (setq sideline-backends-left-skip-current-line t   ; don't display on current line (left)
          sideline-backends-right-skip-current-line t  ; don't display on current line (right)
          sideline-order-left 'down                    ; or 'up
          sideline-order-right 'up                     ; or 'down
          sideline-format-left "%s   "                 ; format for left aligment
          sideline-format-right "   %s"                ; format for right aligment
          sideline-priority 100                        ; overlays' priority
          sideline-display-backend-name t))            ; display the backend name
#+end_src
**** Sideline Flymake
#+begin_src emacs-lisp
(use-package sideline-flymake
  :hook (flymake-mode . sideline-mode)
  :init
    (setq sideline-flymake-display-mode 'line) ; 'line or 'point
    (setq sideline-backends-right '(sideline-flymake)))
#+end_src
*** Sudo Edit
#+begin_src emacs-lisp
(use-package sudo-edit)
#+end_src
** Programming Modes
*** Python Mode
#+begin_src emacs-lisp
(add-hook 'python-ts-mode-hook #'(lambda()
  (setq tab-width 4
        indent-tabs-mode nil)))
#+end_src
*** Javascript Mode
#+begin_src emacs-lisp
(add-hook 'js-ts-mode-hook #'(lambda()
  (setq tab-width 2
        indent-tabs-mode nil
        js-indent-level 2)))
#+end_src
*** TypeScript Mode
#+begin_src emacs-lisp
(add-hook 'typescript-ts-mode-hook #'(lambda()
  (setq tab-width 2
        indent-tabs-mode nil)))
#+end_src
*** Vue Mode
#+begin_src emacs-lisp 
(use-package vue-mode :mode "\\.vue\\'")

(add-hook 'vue-mode-hook #'(lambda()
  (setq tab-width 2
        indent-tabs-mode nil)))
#+end_src
*** Go Mode
#+begin_src emacs-lisp
(add-hook 'go-ts-mode-hook #'(lambda()
  (setq tab-width 4
        go-ts-mode-indent-offset 4
        indent-tabs-mode nil)))
#+end_src
*** Nix Mode
#+begin_src emacs-lisp
(use-package nix-ts-mode :mode "\\.nix\\'")
(add-hook 'nix-ts-mode #'(lambda()
  
))
#+end_src
*** Lua Mode
#+begin_src emacs-lisp
(use-package lua-mode :mode "\\.lua\\'")

(add-hook 'lua-mode-hook #'(lambda()
  (setq tab-width 4)))
#+end_src
*** Elixir Mode
#+begin_src emacs-lisp
(use-package elixir-ts-mode :mode "\\.exs\\'")
#+end_src
*** Rust Mode
#+begin_src emacs-lisp
(add-hook 'rust-ts-mode-hook #'(lambda()
  (setq tab-width 4)))
#+end_src
*** PowerShell Mode
#+begin_src emacs-lisp
(use-package powershell)
#+end_src
*** Markdown Mode
#+begin_src emacs-lisp
(use-package markdown-mode :mode "\\.md\\'")
#+end_src
** Style
*** Themes
#+begin_src emacs-lisp
(use-package catppuccin-theme
  :config
    (setq catppuccin-highlight-matches t)
    ;; (catppuccin-set-color 'base "#11111B")
    (load-theme 'catppuccin :no-confirm))
#+end_src
*** Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :init (doom-modeline-mode 1)
  :config
    (setq doom-modeline-total-line-number t)
    (set-face-attribute 'mode-line nil :background "#11111B")
    ;; (set-face-attribute 'mode-line-inactive nil :background "#25253a")
    (display-time-mode))
#+end_src
*** Nerd Icons
#+begin_src emacs-lisp
(use-package nerd-icons
  :custom
    (nerd-icons-font-family "RobotoMono Nerd Font"))
#+end_src
**** Nerd Icons Dired
#+begin_src emacs-lisp
(use-package nerd-icons-dired
  :config  
    (add-hook 'dired-mode-hook #'nerd-icons-dired-mode))
#+end_src
**** Nerd Icons Dired
#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
*** Highlight TODO
#+begin_src emacs-lisp
(use-package hl-todo
  :config
    (global-hl-todo-mode)
    (setq hl-todo-keyword-faces
        '(("TODO"   . "#FF0000")
          ("FIXME"  . "#FF0000")
          ("DEBUG"  . "#A020F0")
          ("GOTCHA" . "#FF4500")
          ("STUB"   . "#1E90FF"))))
#+end_src
*** Rainbow Mode
#+begin_src emacs-lisp
(use-package rainbow-mode
  :config
    (add-hook 'prog-mode-hook #'rainbow-mode))
#+end_src
*** Rainbow Delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src
*** Treesitter
#+begin_src emacs-lisp
;; sexiest lock level
(setq-default treesit-font-lock-level 4)

;; where to source the langs
(setq treesit-language-source-alist
  '((nix "https://github.com/nix-community/tree-sitter-nix")
    (c "https://github.com/tree-sitter/tree-sitter-c")
    (python "https://github.com/tree-sitter/tree-sitter-python")
    (javascript "https://github.com/tree-sitter/tree-sitter-javascript")
    (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
    (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
    (json "https://github.com/tree-sitter/tree-sitter-json")
    (toml "https://github.com/tree-sitter/tree-sitter-toml")
    (yaml "https://github.com/ikatyang/tree-sitter-yaml")
    (elixir "https://github.com/elixir-lang/tree-sitter-elixir")
    (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
    (rust "https://github.com/tree-sitter/tree-sitter-rust")
    ;; (html "https://github.com/tree-sitter/tree-sitter-html") ;not used yet cant find a good html-ts-mode and I dont feel like making one
    (css "https://github.com/tree-sitter/tree-sitter-css")
    (go "https://github.com/tree-sitter/tree-sitter-go")
    (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
    (java "https://github.com/tree-sitter/tree-sitter-java")
    (bash "https://github.com/tree-sitter/tree-sitter-bash")))

;; auto install any missing defined langs
(dolist (lang treesit-language-source-alist)
  (unless (treesit-language-available-p (car lang))
    (treesit-install-language-grammar (car lang))))

;; maps the ts modes to normal modes
(add-to-list 'major-mode-remap-alist '(c-mode . c-ts-mode))
(add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
(add-to-list 'major-mode-remap-alist '(sh-mode . bash-ts-mode))
(add-to-list 'major-mode-remap-alist '(css-mode . css-ts-mode))
(add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
(add-to-list 'major-mode-remap-alist '(javascript-mode . js-ts-mode))
(add-to-list 'major-mode-remap-alist '(java-mode . java-ts-mode))

;; for modes that have an existing ts mode but no existing normal mode
(add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
(add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-ts-mode))
(add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-ts-mode))
(add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
(add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))

;; If you need to override the names of the expected libraries, defualt emacs looks for libtree-sitter-${LANG_NAME}
;; (setq treesit-load-name-override-list
;;    '((cc "libtree-sitter-c")
;;      (gomod "libtree-sitter-go")))
#+end_src





