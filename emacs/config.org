#+TITLE: Justinlime's Emacs
#+AUTHOR: justinlime
#+DESCRIPTION: Justinlime's Emacs
#+PROPERTY: header-args :tangle yes
#+STARTUP: showeverything, inlineimages

* TABLE OF CONTENTS :TOC_4:
- [[#general][General]]
  - [[#package-manger][Package Manger]]
  - [[#misc-preferences][Misc Preferences]]
  - [[#custom-functions][Custom Functions]]
    - [[#toggle-term][Toggle-Term]]
    - [[#misc][Misc]]
- [[#keybinds][Keybinds]]
  - [[#evil-mode][Evil Mode]]
  - [[#general-binds][General Binds]]
  - [[#keychord-binds][Keychord Binds]]
- [[#functionality][Functionality]]
  - [[#general-1][General]]
    - [[#which-key][Which Key]]
    - [[#neotree][Neotree]]
    - [[#tramp][Tramp]]
    - [[#perspective][Perspective]]
    - [[#affe][Affe]]
    - [[#consult][Consult]]
    - [[#marginalia][Marginalia]]
    - [[#undo-tree][Undo Tree]]
    - [[#terminal-emacs][Terminal Emacs]]
  - [[#programming][Programming]]
    - [[#direnv][Direnv]]
    - [[#lspcompletion][LSP/Completion]]
      - [[#outline][Outline]]
      - [[#eglot][Eglot]]
      - [[#corfu][Corfu]]
      - [[#cape][Cape]]
      - [[#orderless][Orderless]]
      - [[#vertico][Vertico]]
      - [[#yasnippet][Yasnippet]]
    - [[#magit][Magit]]
    - [[#git-gutter][Git Gutter]]
    - [[#prog-modes][Prog Modes]]
      - [[#python-mode][Python Mode]]
      - [[#javascript-mode][Javascript Mode]]
      - [[#typescript-mode][TypeScript Mode]]
      - [[#vue-mode][Vue Mode]]
      - [[#go-mode][Go Mode]]
      - [[#nix-mode][Nix Mode]]
      - [[#lua-mode][Lua Mode]]
      - [[#elixir-mode][Elixir Mode]]
      - [[#rust-mode][Rust Mode]]
      - [[#powershell-mode][PowerShell Mode]]
  - [[#modes][Modes]]
    - [[#markdown-mode][Markdown Mode]]
    - [[#erc-mode][Erc Mode]]
    - [[#term-mode][Term Mode]]
    - [[#org-mode][Org Mode]]
      - [[#org-general][Org General]]
      - [[#org-table-of-contents][Org Table of Contents]]
      - [[#org-modern][Org Modern]]
      - [[#org-roam][Org Roam]]
- [[#look--feel][Look & Feel]]
  - [[#general-2][General]]
    - [[#themes][Themes]]
    - [[#dired][Dired]]
    - [[#modeline][Modeline]]
    - [[#gui-settings][GUI Settings]]
    - [[#scrolling][Scrolling]]
    - [[#fonts][Fonts]]
    - [[#icons][Icons]]
    - [[#dashboard][Dashboard]]
  - [[#programming-1][Programming]]
    - [[#highlight-todo][Highlight TODO]]
    - [[#rainbow-mode][Rainbow Mode]]
    - [[#rainbow-delimiters][Rainbow Delimiters]]
    - [[#treesitter][Treesitter]]

* General
** Package Manger
#+begin_src emacs-lisp 
(defvar elpaca-installer-version 0.6)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (call-process "git" nil buffer t "clone"
                                       (plist-get order :repo) repo)))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))

;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable :elpaca use-package keyword.
  (elpaca-use-package-mode)
  ;; Assume :elpaca t unless otherwise specified.
  (setq elpaca-use-package-by-default t))

;; Block until current queue processed.
(elpaca-wait)

;;When installing a package which modifies a form used at the top-level
;;(e.g. a package which adds a use-package key word),
;;use `elpaca-wait' to block until that package has been installed/configured.
;;For example:
;;(use-package general :demand t)
;;(elpaca-wait)


;;Turns off elpaca-use-package-mode current declartion
;;Note this will cause the declaration to be interpreted immediately (not deferred).
;;Useful for configuring built-in emacs features.
(use-package emacs :elpaca nil :config (setq ring-bell-function #'ignore))

;; Don't install anything. Defer execution of BODY
(elpaca nil (message "deferred"))
#+end_src
** Misc Preferences 
#+begin_src emacs-lisp
;; revert inflated GC defined in early init to avoid GC pauses while editing
(run-with-idle-timer 1 nil
  (lambda ()
    (setq gc-cons-threshold 1000000)
    (message "gc-cons-threshold restored to %S" gc-cons-threshold)))
;; Enable mouse in term-mode
(unless (display-graphic-p)
  (xterm-mouse-mode 1))
(setq make-backup-files nil ; stop creating ~ files
      auto-save-default nil ; Disable autosave # files
      create-lockfiles nil ; Disable .# files
      blink-cursor-mode nil ; Exactly what is sounds like
      use-short-answers t ; Set y or n instead of yes or no for questions
      inhibit-startup-messages t ; Disable splash screen
      password-cache-expiry nil) ; so tramp doesnt keep prompting for passwords while connected

(setq-default tab-width 2 ; self explanitory
              indent-tabs-mode nil) ; use spaces not tabs
(electric-pair-mode 1) ; Auto closing pairs like () and {}
(save-place-mode) ; Save cursor position in buffer on reopen
(put 'dired-find-alternate-file 'disabled nil) ;Allow "dired-find-alternate-file to work without a prompt"
(global-hl-line-mode)
(electric-indent-mode t)

;; Kill *Help* after :q'ing, and kill magit buffers when quitting them
(advice-add #'evil-quit :after #'(lambda(&rest r)
  (let ((buf (get-buffer "*Help*")))
    (if (eq buf nil) nil
      (kill-buffer buf))
    (dolist (b (magit-mode-get-buffers))
        (kill-buffer b)))))

;; Disables all startup warnings, and kills message buffer, comment this out when debugging
(setq warning-minimum-level :emergency)
(setq-default message-log-max nil)
(add-hook 'dashboard-mode-hook #'(lambda() ;Kills the warning buffer for even emergency messages
  (kill-buffer (get-buffer "*Warnings*"))
  (kill-buffer (get-buffer "*Messages*"))
  (keyboard-escape-quit)))
#+end_src
** Custom Functions
*** Toggle-Term
#+begin_src emacs-lisp
;; This is sphagetti code but I dont care
(let ((init-term "*toggle-term-main*"))
  (defvar jl/active-toggle-term `(("main" ,init-term)) "The most recently used toggle term")
  (defvar jl/current-toggles `(("main" (,init-term))) "List of the current toggle terms"))

(defun jl/toggle-term (&optional name command)
  "Toggle a terminal window with $SHELL, and make it the active term

  If NAME is not provided, prompt to user for one. Closes any other toggle-terms
  currently open that aren't NAME

  NAME can be in the *name* format or just name, but the buffers' name will always output to *name*

  Integrated with perspective.el

  If COMMAND is set, the created terminal will execute the command using your shell's -c flag"
  (interactive)
  ;; Create a key and default value for the alist if it doesnt exist for the perspective 
  (if (eq (assoc (persp-current-name) jl/current-toggles) nil)
    (progn
      (let ((wrapped-name (format "*toggle-term-%s*" (persp-current-name))))
        (add-to-list 'jl/current-toggles `(,(persp-current-name) (,wrapped-name)))
        (setq name wrapped-name)
        (setq jl/active-toggle-term (cons `(,(persp-current-name) ,wrapped-name) jl/active-toggle-term)))))
  (let* (
    (current-toggles-persp (car (cdr (assoc (persp-current-name) jl/current-toggles))))
    ;; Wrapping and unwrapping to force a *name* naming scheme
    (name (if name name (completing-read "Toggle-Term: " current-toggles-persp)))
    (unwrapped-name (replace-regexp-in-string "\\*" "" name))
    (wrapped-name (format "*%s*" unwrapped-name))) 
      ;; Check if another toggle-term is active
      (dolist (c current-toggles-persp)
        (if (string-equal c wrapped-name)
          nil
          (let ((w (get-buffer-window c)))
            (if w (delete-window w)))))
        ;; Toggle the term
        (let (
          (height (window-total-height))
          (window (get-buffer-window wrapped-name)))
            (if window (delete-window window)
                ;; Creates a window below the current window at 22% of the windows height
                (select-window (split-root-window-below (round (* height 0.78))))
                ;; If command is provided, start the term using the shells -c flag
                (if (eq command nil)
                  (make-term unwrapped-name (getenv "SHELL")) ; The make-term function automatically wraps *'s around the name given, hence the unwrapped name being used.
                  (make-term unwrapped-name (getenv "SHELL") nil "-c" command)) 
                ;; Sets the active terminal for the current perspective in the alist
                (let ((key (assoc (persp-current-name) jl/active-toggle-term)))
                  (if key
                    (setcdr key `(,wrapped-name))
                    (setq jl/active-toggle-term (cons `(,(persp-current-name) ,wrapped-name) jl/active-toggle-term))))
                ;; Adds the terminal to the current-toggles alist if its not already included
                (if (member wrapped-name current-toggles-persp) nil
                  (let* ((key (assoc (persp-current-name) jl/current-toggles))
                         (orig-list (car(cdr key))))
                    (if key
                      (progn
                        (add-to-list 'orig-list wrapped-name)
                        (setcdr key `(,orig-list)))
                      (add-to-list 'jl/current-toggles `(,(persp-current-name) (,wrapped-name))))))
                ;; Switch to the buffer and enter insert mode
                (switch-to-buffer wrapped-name)
                (evil-insert 1)))))

(defun jl/toggle-active-term ()
  "Toggle the most recently used toggle-term"
  (interactive)
  (jl/toggle-term (car (cdr (assoc (persp-current-name) jl/active-toggle-term)))))
#+end_src
*** Misc
#+begin_src emacs-lisp
(defun jl/ssh (host formatter)
  (persp-switch host)
  (advice-add #'read-passwd :around #'jl/capture-password)
  (let ((format-host (format formatter host host)))
    (find-file format-host)
    (jl/toggle-term host (format "ssh %s" host)))
  ;; Poll the buffer every .2 seconds for the prompt
  (setq jl/password-timer (run-at-time .20 .20 #'(lambda()
  (if (string-match "Enter Passphrase for key" (buffer-string))
    (progn
      (jl/str-to-input jl/pass)
      (execute-kbd-macro (kbd "RET"))
      (setq jl/pass nil)
      (cancel-timer jl/password-timer)
      (advice-remove #'read-passwd #'jl/capture-password)))))))
(defun jl/ssh-root (host)
  "SSH with sudo privledges using a host from .ssh/config"
  (interactive "sEnter host: ")
  (jl/ssh host "/ssh:%s|sudo:%s:/"))
(defun jl/ssh-user (host)
  "SSH using a host from .ssh/config"
  (interactive "sEnter host: ")
  (jl/ssh host "/ssh:%s:~"))

(defvar jl/pass nil)
(defun jl/capture-password (orig-func &rest args)
  "Capture the password temporarily to send to send somewhere
   Probably pretty insecure but I dont really care"

  (let ((pass (apply orig-func args)))
    ;; only capture if jl/pass is not active
    (if (eq jl/pass nil)
      (setq jl/pass pass)
      (run-at-time 60 nil #'(lambda()
          ;; clear the pass from memory
          (setq jl/pass nil))))
    ;; always return the original value so the orig-function works like normal
    pass))

(defun jl/str-to-input (str)
  (mapc (lambda (char)
    (execute-kbd-macro (char-to-string char)))
    str))

(defun jl/consult-find-in-dir ()
  "Find a file in a specific directory
   
  Uses Affe if working with local files, and Consult for remote files"
  (interactive)
  (let ((dir (file-name-directory (read-file-name "Find in directory: "))))
    (if (string-prefix-p "/ssh:" default-directory)
      (consult-find dir)
      (affe-find dir))))
(defun jl/consult-find-in-current ()
  "Find a file in the project's directory

  Sets the root of the search to the folders' .git parent path if present

  Uses Affe if working with local files, and Consult for remote files"
  (interactive)
  (let ((dir (magit-toplevel default-directory)))
    (if (string-prefix-p "/ssh:" default-directory)
      (if dir
        (consult-find dir)
        (consult-find))
      (if dir
        (affe-find dir)
        (affe-find)))))

(defun jl/consult-grep-in-dir ()
  "Find a word in a specified project/folder

  Uses Ripgrep if working with local files, and Grep for remote files"
  (interactive)
  (let ((dir (file-name-directory (read-file-name "Find in directory: "))))
    (if (string-prefix-p "/ssh:" default-directory)
      (consult-grep dir)
      (consult-ripgrep dir))))

(defun jl/consult-grep-in-current ()
  "Find a word in the current project/folder

  Sets the root of the search to the folders' .git parent path if present

  Uses Ripgrep if working with local files, and Grep for remote files"
  (interactive)
  (let ((dir (magit-toplevel default-directory)))
    (if dir
      (if (string-prefix-p "/ssh:" default-directory)
        (consult-grep dir)
        (consult-ripgrep dir))
      (if (string-prefix-p "/ssh:" default-directory)
        (consult-grep)
        (consult-ripgrep)))))

(defun jl/random-quote ()
  "Generate a random quote for dashboard"
  (interactive)
  (let ((ops '(
    "Hello World!"
    "Whopper Whopper Whopper Whopper Junior Double Triple Whopper"
    "sudo systemctl stop justinlime"
    "sudo systemctl start justinlime"
    "sudo systemctl restart justinlime"
    "White Monster"
    "https://stinkboys.com"
    "Stink Boys Inc. ©"
    "/home/justinlime/.config"
    "No emacs???"))) (nth (random (length ops)) ops)))
(defun jl/random-icon ()
  "Generate a random image for dashboard"
  (interactive)
  (let* ((icons-dir (expand-file-name "icons/" user-emacs-directory))
        (ops (directory-files icons-dir))
        (ops (delete "." ops))
        (ops (delete ".." ops))
        (file (nth (random (length ops)) ops)))
          (expand-file-name file icons-dir)))
(defun jl/dired-open ()
  "Open path in the same buffer if a file, and a new one if a directory in dired"
  (interactive)
  (if (file-directory-p (dired-get-file-for-visit))
    (dired-find-alternate-file)
    (dired-find-file)))

(defun jl/symbols-outline-toggle ()
  "Toggle the symbols outline"
  (interactive)
  (let ((w (get-buffer-window "*Outline*")))
    (if w 
      (delete-window w)
      (symbols-outline-show))))
#+end_src

* Keybinds
** Evil Mode
#+begin_src emacs-lisp
;; Expands to: (elpaca evil (use-package evil :demand t))
(use-package evil
  :init      ;; tweak evil's configuration before loading it
  (setq evil-want-integration t ;; This is optional since it's already set to t by default.
        evil-want-keybinding nil
        evil-vsplit-window-right t
        evil-split-window-below t
        evil-shift-width 4)
  (evil-mode))
(use-package evil-collection
  :after evil
  :config
  (setq evil-collection-mode-list '(magit term neotree help dashboard dired ibuffer tetris))
  (evil-collection-init))
(use-package evil-tutor)

#+end_src
** General Binds
#+begin_src emacs-lisp
(use-package general
  :config
  ;; Term Mode
  (add-hook 'term-mode-hook #'(lambda()
  (general-define-key
    :states 'insert
    :keymaps 'term-raw-map
    "TAB" #'(lambda() (interactive) (term-send-raw-string "\t")))))

  ;; Neotree
  (add-hook 'neotree-mode-hook #'(lambda()
  (general-define-key
    :states 'normal
    :keymaps 'neotree-mode-map
    "<tab>" #'neotree-change-root
    "TAB" #'neotree-change-root)))

  ;; Fix escape key on in emacs terminal mode
  ;; Minibuffer 
  (general-define-key
    :keymaps 'minibuffer-local-map
    "<escape>" #'keyboard-escape-quit)

  ;; Dired
  ;; Stops dired from making a new buffer every time you hit RET
  (general-define-key
    :states '(normal insert)
    :keymaps 'dired-mode-map
    "RET" #'jl/dired-open)

  ;; Corfu
  (general-define-key
    :states 'insert
    :keymaps 'corfu-map
    "<tab>" #'corfu-next
    "TAB" #'corfu-next
    "<backtab>" #'corfu-previous)
  ;; Prevent evil from overriding corfu bindings
  (with-eval-after-load #'corfu
    (advice-add #'corfu--setup :after #'(lambda(&rest r) (evil-normalize-keymaps)))
    (advice-add #'corfu--teardown :after #'(lambda(&rest r) (evil-normalize-keymaps)))
    (evil-make-overriding-map corfu-map))

  ;; Vertico
  (general-define-key
   :keymaps 'vertico-map
   "RET" #'vertico-directory-enter
   "<tab>" #'vertico-next
   "TAB" #'vertico-next
   "<backspace>" #'vertico-directory-delete-char
   "DEL" #'vertico-directory-delete-char
   "<backtab>" #'vertico-previous)

  ;; Symbol Outlines
  (general-define-key
   :states 'normal
   :keymaps 'symbols-outline-mode-map
   "RET" #'symbols-outline-visit
   "<tab>" #'symbols-outline-toggle-node)

  ;; Org
  (general-define-key
    :states 'normal 
    :keymaps 'org-mode-map
    "RET" #'org-open-at-point
    "<tab>" #'org-cycle
    "TAB" #'org-cycle)

  ;; Evil
  (general-define-key
    :states 'insert
    "<tab>" #'tab-to-tab-stop
    "TAB" #'tab-to-tab-stop)
  (general-define-key
    :states '(normal insert visual emacs)
    "C-u" #'evil-scroll-up
    "C-d" #'evil-scroll-down)
  (general-define-key
    :states '(normal emacs)
    "J" #'shrink-window
    "K" #'enlarge-window
    "H" #'shrink-window-horizontally
    "L" #'enlarge-window-horizontally
    "u" #'undo-tree-undo
    "R" #'undo-tree-redo)

  ;; set up 'SPC' as the global leader key
  (general-create-definer leader
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode

  (leader
    "w" '(:ignore t :wk "Window Navigation")
    "w h" '(evil-window-left :wk "Move left to window")
    "w j" '(evil-window-down :wk "Move down to window")
    "w k" '(evil-window-up :wk "Move up to window")
    "w l" '(evil-window-right :wk "Move right to window")
    "w s" '(evil-window-split :wk "Split window horizontally")
    "w v" '(evil-window-vsplit :wk "Split window vertically"))
  (leader
    "b" '(:ignore t :wk "Buffer")
    "b f" '(persp-switch-to-buffer* :wk "Find a buffer, or create a new one")
    "b i" '(persp-ibuffer :wk "Buffer Menu (IBuffer)")
    "b k" '(kill-this-buffer :wk "Kill this buffer")
    "b r" '(revert-buffer :wk "Reload this buffer"))
  (leader
    "e" '(:ignore t :wk "Evaluate")    
    "e b" '(eval-buffer :wk "Evaluate elisp in buffer")
    "e e" '(eval-expression :wk "Evaluate and elisp expression")
    "e r" '(eval-region :wk "Evaluate selected elisp")) 
  (leader
    "h" '(:ignore t :wk "Help")
    "h f" '(describe-function :wk "Help function")
    "h v" '(describe-variable :wk "Help variable")
    "h m" '(describe-mode :wk "Help mode")
    "h c" '(describe-char :wk "Help character")
    "h k" '(describe-key :wk "Help key/keybind"))
  (leader
    "d" '(:ignore t :wk "Directory Tree")
    "d t" '(neotree-toggle :wk "Toggle Directory Tree")
    "d r" '(neotree-dir :wk "Change Directory Root"))
  (leader
    "o" '(:ignore t :wk "Symbols Outline")
    "o t" '(jl/symbols-outline-toggle :wk "Toggle the symbol outline"))
  (leader
    "f" '(:ignore t :wk "Find file")
    "f f" '(find-file :wk "Find file directly")
    "f r" '(jl/consult-find-in-current :wk "Find file in current dir/project")
    "f R" '(jl/consult-find-in-dir :wk "Find file in specified dir/project")
    "f w" '(jl/consult-grep-in-current :wk "Find word in current dir/project")
    "f W" '(jl/consult-grep-in-dir :wk "Find word in specified dir/project"))
  (leader
    "c" '(:ignore t :wk "Comment")
    "c r" '(comment-region :wk "Comment selection")
    "c l" '(comment-line :wk "Comment line"))
  (leader
    "t" '(:ignore t :wk "Toggle-Term")
    "t t" '(jl/toggle-active-term :wk "Toggle the active toggle-term")
    "t f" '(jl/toggle-term :wk "Find a toggle-term, or create a new one"))
  (leader
    "r" '(:ignore t :wk "Org Roam")
    "r f" '(org-roam-node-find :wk "Find org roam file")
    "r t" '(org-roam-buffer-toggle :wk "Toggle the roam buffer")
    "r c" '(org-capture-finalize :wk "Capture the roam buffer")
    "r i" '(org-roam-node-insert :wk "Insert node link"))
  (leader
    "g" '(:ignore t :wk "Magit")
    "g s" '(magit-stage-file :wk "Stage Files")
    "g S" '(magit-stage-modified :wk "Stage All Files")
    "g u" '(magit-unstage-file :wk "Unstage Files")
    "g U" '(magit-unstage-all :wk "Unstage All Files")
    "g f" '(magit-fetch :wk "Fetch")
    "g F" '(magit-fetch-all :wk "Fetch")
    "g i" '(magit-init :wk "Init")
    "g l" '(magit-log :wk "Log")
    "g b" '(magit-branch :wk "Branch")
    "g d" '(magit-diff :wk "Diff")
    "g c" '(magit-commit :wk "Commit")
    "g r" '(magit-rebase :wk "Rebase")
    "g R" '(magit-reset :wk "Reset")
    "g p" '(magit-push :wk "Push")
    "g P" '(magit-pull :wk "Pull")
    "g m" '(magit :wk "Magit Menu"))
  (leader
    "p" '(:ignore t :wk "Perspective")
    "p f" '(persp-switch :wk "Find perspective, or create new one")
    "p h" '(persp-prev :wk "Previous perspective")
    "p l" '(persp-next :wk "Next perspective")
    "p k" '((lambda () (interactive) (if (yes-or-no-p "Kill the current perspective?")(persp-kill (persp-current-name)))) :wk "Kill the current perspective")
    "p 1" '((lambda () (interactive) (persp-switch-by-number 1)) :wk "Switch to perspective 1")
    "p 2" '((lambda () (interactive) (persp-switch-by-number 2)) :wk "Switch to perspective 2")
    "p 3" '((lambda () (interactive) (persp-switch-by-number 3)) :wk "Switch to perspective 3")
    "p 4" '((lambda () (interactive) (persp-switch-by-number 4)) :wk "Switch to perspective 4")
    "p 5" '((lambda () (interactive) (persp-switch-by-number 5)) :wk "Switch to perspective 5")
    "p 6" '((lambda () (interactive) (persp-switch-by-number 6)) :wk "Switch to perspective 6")
    "p 7" '((lambda () (interactive) (persp-switch-by-number 7)) :wk "Switch to perspective 7")
    "p 8" '((lambda () (interactive) (persp-switch-by-number 8)) :wk "Switch to perspective 8")
    "p 9" '((lambda () (interactive) (persp-switch-by-number 9)) :wk "Switch to perspective 9")
    "p 0" '((lambda () (interactive) (persp-switch-by-number 0)) :wk "Switch to perspective 0"))
  (leader
    "s" '(:ignore t :wk "SSH")
    "s u" '(jl/ssh-user :wk "SSH as user, using the ssh config file")
    "s r" '(jl/ssh-root :wk "SSH as user with root privledges, using the ssh config file")))
#+end_src
** Keychord Binds
#+begin_src emacs-lisp
(use-package key-chord
  :init
  (key-chord-mode 1)
  :config
  (setq key-chord-two-keys-delay 1
        key-chord-one-key-delay 1.2
        key-chord-safety-interval-forward 0.1
        key-chord-safety-interval-backward 1)
  (key-chord-define evil-insert-state-map  "jj" 'evil-normal-state))
#+end_src 

* Functionality
** General
*** Which Key
#+begin_src emacs-lisp 
(use-package which-key
  :init
  (which-key-mode 1)
  :config
  (setq which-key-side-window-location 'bottom
		which-key-sort-order #'which-key-key-order-alpha
		which-key-sort-uppercase-first nil
		which-key-add-column-padding 1
		which-key-max-display-columns nil
		which-key-min-display-lines 6
		which-key-side-window-slot -10
		which-key-side-window-max-height 0.25
		which-key-idle-delay 0.8
		which-key-max-description-length 25
		which-key-allow-imprecise-window-fit t
		which-key-separator " → " ))
#+end_src
*** Neotree
#+begin_src emacs-lisp
(use-package neotree
  :config
  (progn
    (setq neo-smart-open t)
    (setq neo-theme (if (display-graphic-p) 'nerd))))

  ;; (add-hook 'persp-activated-hook #'(lambda ()
  ;;   (if (neo-global--window-exists-p) (neotree-toggle)))) 
  (add-hook 'neotree-mode-hook #'(lambda ()
    (face-remap-set-base 'default :background "#181825")
    (face-remap-set-base 'fringe :background "#181825")
    (display-line-numbers-mode -1))) 
#+end_src
*** Tramp
#+begin_src emacs-lisp
;; Speeds up tramp allegedly
(with-eval-after-load 'tramp
  (setq tramp-inline-compress-start-size 1000
        tramp-copy-size-limit 10000
        vc-handled-backends '(git)
        tramp-default-method "rcp"
        tramp-use-ssh-controlmaster-options nil
        projectile--mode-line "Projectile"))
#+end_src
*** Perspective
#+begin_src emacs-lisp
(use-package perspective
  :init
  (setq persp-suppress-no-prefix-key-warning t)
  (persp-mode)
  :config
  (setq persp-sort 'created)
  ;; Overriding the function to reverse the sorting order
  (defun persp-names ()
    "Return a list of the names of all perspectives on the `selected-frame'.

  If `persp-sort' is 'name (the default), then return them sorted
  alphabetically. If `persp-sort' is 'access, then return them
  sorted by the last time the perspective was switched to, the
  current perspective being the first. If `persp-sort' is 'created,
  then return them in the order they were created, with the newest
  first."
    (let ((persps (hash-table-values (perspectives-hash))))
      (cond ((eq persp-sort 'created)
               (mapcar 'persp-name
                 (sort persps (lambda (a b)
                   (time-less-p (persp-created-time a)
                     (persp-created-time b))))))))))
#+end_src
*** Affe
#+begin_src emacs-lisp
(use-package affe)
#+end_src
*** Consult
#+begin_src emacs-lisp
(use-package consult
  :config
  (setq consult-find-args "find . -not ( -path '*/.git*' -prune ) -not ( -path '*.git*' -prune )"))
#+end_src
*** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :init
  (marginalia-mode))
#+end_src
*** Undo Tree
#+begin_src emacs-lisp
(use-package undo-tree
  :config
  (global-undo-tree-mode)
  (setq undo-tree-auto-save-history t)
  (setq undo-tree-history-directory-alist '(("." . "~/.config/emacs/undo"))))
#+end_src
*** Terminal Emacs
#+begin_src emacs-lisp
;; These hooks may not work if TERM isnt xterm/xterm256
;; Let cursor change based on mode when in Terminal Emacs
;; (Not to be confused with term-mode) this is for when running emacs in the terminal

;; This is a really hacky fix
(unless (display-graphic-p)
  (defun correct-cursor (&rest r)
    (setq visible-cursor nil) 
    (if (eq evil-state 'insert)
      (send-string-to-terminal "\e[5 q")
      (send-string-to-terminal "\e[2 q")))
  (add-hook 'evil-insert-state-entry-hook #'correct-cursor)
  (add-hook 'evil-normal-state-entry-hook #'correct-cursor)
  (advice-add 'eldoc-documentation-default :after #'correct-cursor) ;;Echo Area
  (advice-add 'eldoc-display-in-buffer :after #'correct-cursor)) ;;Buffer
#+end_src
** Programming
*** Direnv
#+begin_src emacs-lisp
(use-package envrc
  :config
  (envrc-global-mode))
#+end_src
*** LSP/Completion
**** Outline
#+begin_src emacs-lisp
(use-package symbols-outline
  :config
  (setq symbols-outline-fetch-fn #'symbols-outline-lsp-fetch
        symbols-outline-window-position 'right
        symbols-outline-no-other-window nil
        symbols-outline-window-width '30)
  (add-hook 'symbols-outline-mode-hook #'(lambda ()
    (face-remap-set-base 'default :background "#181825")
    (face-remap-set-base 'fringe :background "#181825")
    (display-line-numbers-mode -1)))
  (symbols-outline-follow-mode))
#+end_src
**** Eglot
#+begin_src emacs-lisp
;; Override the binary being used on startup
(with-eval-after-load 'eglot
  (add-to-list 'eglot-server-programs
               '((java-ts-mode java-mode) . ("java-language-server")))
  (add-to-list 'eglot-server-programs
               '((nix-ts-mode nix-mode) . ("nixd"))))

;; (defun jl/eglot-find-file-hook ()
;;   (eglot-ensure)
;;   (symbols-outline-show))
(defvar jl/eglot-enabled-langs 
    '(go-ts-mode  
      python-ts-mode
      js-ts-mode
      typescript-ts-mode
      rust-ts-mode
      elixir-ts-mode
      nix-ts-mode
      java-ts-mode
      c-ts-mode
      bash-ts-mode))

(add-hook 'find-file-hook #'(lambda()
    (unless (file-remote-p (buffer-file-name)) 
      (dolist (lang jl/eglot-enabled-langs)
        (if (eq major-mode lang)
          (progn
            
            (eglot-ensure)))))))
#+end_src
**** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :ensure t
  :config
  (setq corfu-popupinfo-delay 0)
  :custom
  (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
  (corfu-auto t)
  (corfu-cycle t)
  (corfu-preselect 'prompt)
  (corfu-auto-delay 0.2)
  (corfu-auto-prefix 2)
  :init
  (corfu-popupinfo-mode)
  (global-corfu-mode)
  (corfu-history-mode))

(use-package corfu-terminal
  :ensure t
  :config
  (unless (display-graphic-p)
    (corfu-terminal-mode 1)))
#+end_src
**** Cape
#+begin_src emacs-lisp
(use-package cape
  :init
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  (add-to-list 'completion-at-point-functions #'cape-keyword))
#+end_src
**** Orderless
#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
**** Vertico
#+begin_src emacs-lisp
(use-package vertico
  :init
  (vertico-mode))
#+end_src
**** Yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :config
  (setq yas-snippet-dirs `(,(expand-file-name "snips/" user-emacs-directory)))
  (yas-global-mode 1))
(use-package yasnippet-snippets)
(use-package yasnippet-capf
  :after cape
  :config
  (setq yasnippet-capf-lookup-by 'name) ;; Prefer the name of the snippet instead
  (add-to-list 'completion-at-point-functions #'yasnippet-capf))

#+end_src
*** Magit
#+begin_src emacs-lisp
(use-package seq) ; Magit needs a newer version of seq
(use-package magit)
(add-hook 'magit-post-stage-hook #'(lambda ()
  (message "Staged")))
#+end_src
*** Git Gutter
#+begin_src emacs-lisp
(use-package git-gutter)

;; Disable git-gutter over tramp
(add-hook 'find-file-hook #'(lambda()
  (unless (file-remote-p (buffer-file-name))
    (git-gutter-mode t))))
#+end_src
*** Prog Modes
**** Python Mode
#+begin_src emacs-lisp
(add-hook 'python-ts-mode-hook #'(lambda()
  (setq tab-width 4
        indent-tabs-mode nil)))
#+end_src
**** Javascript Mode
#+begin_src emacs-lisp
(add-hook 'js-ts-mode-hook #'(lambda()
  (setq tab-width 2
        indent-tabs-mode nil
        js-indent-level 2)))
#+end_src
**** TypeScript Mode
#+begin_src emacs-lisp
(add-hook 'typescript-ts-mode-hook #'(lambda()
  (setq tab-width 2
        indent-tabs-mode nil)))
#+end_src
**** Vue Mode
#+begin_src emacs-lisp 
(use-package vue-mode :mode "\\.vue\\'")

(add-hook 'vue-mode-hook #'(lambda()
  (setq tab-width 2
        indent-tabs-mode nil)))
#+end_src
**** Go Mode
#+begin_src emacs-lisp
(add-hook 'go-ts-mode-hook #'(lambda()
  (setq tab-width 4
        go-ts-mode-indent-offset 4
        indent-tabs-mode nil)))
#+end_src
**** Nix Mode
#+begin_src emacs-lisp
(use-package nix-ts-mode :mode "\\.nix\\'")
(add-hook 'nix-ts-mode #'(lambda()
  
))
#+end_src
**** Lua Mode
#+begin_src emacs-lisp
(use-package lua-mode :mode "\\.lua\\'")

(add-hook 'lua-mode-hook #'(lambda()
  (setq tab-width 4)))
#+end_src
**** Elixir Mode
#+begin_src emacs-lisp
(use-package elixir-ts-mode :mode "\\.exs\\'")
#+end_src
**** Rust Mode
#+begin_src emacs-lisp
(add-hook 'rust-ts-mode-hook #'(lambda()
  (setq tab-width 4)))
#+end_src
**** PowerShell Mode
#+begin_src emacs-lisp
(use-package powershell)
#+end_src
** Modes
*** Markdown Mode
#+begin_src emacs-lisp
(use-package markdown-mode :mode "\\.md\\'")
#+end_src
*** Erc Mode
#+begin_src emacs-lisp
(add-hook 'erc-mode-hook #'(lambda ()
  (toggle-truncate-lines) ; truncate lines in erc mode
  (persp-add-buffer (current-buffer)) ; fix erc buffers not being listed in buffer menu when using perspective.el
  (display-line-numbers-mode -1)))
#+end_src
*** Term Mode
#+begin_src  emacs-lisp
(add-hook 'term-mode-hook #'(lambda()
  ;; (face-remap-set-base 'default :background "#1b1b2b")
  (face-remap-set-base 'default :background "#11111B")
  (face-remap-set-base 'fringe :background "#11111B")
  (hl-line-mode 'toggle)
  (defface term-background
  '((t (:inherit default :background "#11111B")))
  "Some bullshit to fix term-mode text-background"
  :group 'basic-faces)

  (setf (elt ansi-term-color-vector 0) 'term-background)

  (display-line-numbers-mode -1)))
#+end_src
*** Org Mode
**** Org General
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'(lambda ()
  (org-indent-mode)
  (setq-local electric-indent-mode nil)))

(setq org-src-preserve-indentation t)

#+end_src
**** Org Table of Contents
#+begin_src emacs-lisp
(use-package toc-org
  :commands toc-org-enable
  :init
  (add-hook 'org-mode-hook 'toc-org-enable)
  (add-hook 'markdown-mode-hook 'toc-org-enable))
#+end_src
**** Org Modern
#+begin_src emacs-lisp
(use-package org-modern
  :init 
  (with-eval-after-load 'org (global-org-modern-mode)))
#+end_src
**** Org Roam
#+begin_src emacs-lisp
(use-package org-roam
  :ensure t
  :custom
  (org-roam-directory (file-truename "~/org/roam/"))
  :config
  ;; If you're using a vertical completion framework, you might want a more informative completion interface
  (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  (org-roam-db-autosync-mode 1)
  (require 'org-roam-protocol))
#+end_src

* Look & Feel
** General
*** Themes
#+begin_src emacs-lisp
(set-frame-parameter nil 'alpha-background 100) ; For current frame
(add-to-list 'default-frame-alist '(alpha-background . 100)) ; For all new frames henceforth
(use-package catppuccin-theme
  :config
  (setq catppuccin-highlight-matches t)
  ;; (catppuccin-set-color 'base "#11111B")
  (load-theme 'catppuccin :no-confirm))
#+end_src
*** Dired
#+begin_src emacs-lisp
(use-package diredfl
  :config
  (diredfl-global-mode))
(setq dired-listing-switches "-alFh")
#+end_src
*** Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :config
  (setq doom-modeline-total-line-number t)
  (set-face-attribute 'mode-line nil :background "#11111B")
  ;; (set-face-attribute 'mode-line-inactive nil :background "#25253a")
  (display-time-mode)
  :init (doom-modeline-mode 1))
#+end_src
*** GUI Settings
#+begin_src emacs-lisp
(setq use-dialog-box nil ; No dialog box
      display-line-numbers-type 'relative) ;Realive numbers
(setq-default truncate-lines t) ;Allow truncated lines
(menu-bar-mode -1) ;Disable menu
(tool-bar-mode -1) ;Disable toolbar
(scroll-bar-mode -1) ;Disable scroll bar
(global-display-line-numbers-mode 1) ;Display line numbers
#+end_src
*** Scrolling
#+begin_src emacs-lisp 
(setq-default pixel-scroll-precision-mode t
      mouse-wheel-scroll-amount '(1 ((shift) . 1)) ;; one line at a time
      mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
      mouse-wheel-follow-mouse 't ;; scroll window under mouse
      scroll-margin 1
      scroll-conservatively 0
      scroll-up-aggressively 0.01
      scroll-down-aggressively 0.01)
(unless (display-graphic-p) 
  (setq scroll-conservatively 101))
#+end_src
*** Fonts
#+begin_src emacs-lisp
(set-face-attribute 'default nil
  :font "RobotoMono Nerd Font"
  :height 120
  :weight 'medium)
(set-face-attribute 'variable-pitch nil
  :font "Roboto"
  :height 120
  :weight 'medium)
(set-face-attribute 'fixed-pitch nil
  :font "RobotoMono Nerd Font"
  :height 120
  :weight 'medium)
(setq-default line-spacing 0.12)
(set-language-environment "UTF-8")
#+end_src
*** Icons
#+begin_src emacs-lisp
(use-package nerd-icons
  :custom
  (nerd-icons-font-family "RobotoMono Nerd Font"))

(use-package nerd-icons-dired
  :config  
  (add-hook 'dired-mode-hook #'nerd-icons-dired-mode))

(use-package nerd-icons-corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src
*** Dashboard
#+begin_src emacs-lisp
(use-package dashboard
  :elpaca t
  :config
  (add-hook 'elpaca-after-init-hook #'dashboard-insert-startupify-lists)
  (add-hook 'elpaca-after-init-hook #'dashboard-initialize)
  (setq default-directory "~/"
        initial-buffer-choice (lambda() (get-buffer-create "*dashboard*")) 
        dashboard-banner-logo-title (jl/random-quote)
        dashboard-footer-messages `(,(jl/random-quote)))
  (when (display-graphic-p)
    (setq dashboard-startup-banner (jl/random-icon)))
  (dashboard-setup-startup-hook))

(add-hook 'dashboard-mode-hook #'(lambda() (set-face-attribute
 'line-number-current-line nil :foreground "#cba6f7")))
(add-hook 'dashboard-mode-hook #'(lambda() (set-cursor-color "#cba6f7")))
#+end_src
** Programming
*** Highlight TODO
#+begin_src emacs-lisp
(use-package hl-todo
  :config
  (global-hl-todo-mode)
  (setq hl-todo-keyword-faces
      '(("TODO"   . "#FF0000")
        ("FIXME"  . "#FF0000")
        ("DEBUG"  . "#A020F0")
        ("GOTCHA" . "#FF4500")
        ("STUB"   . "#1E90FF"))))
#+end_src
*** Rainbow Mode
#+begin_src emacs-lisp
(use-package rainbow-mode
  :config
  (add-hook 'prog-mode-hook #'rainbow-mode))
#+end_src
*** Rainbow Delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :config
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src
*** Treesitter
#+begin_src emacs-lisp
;; sexiest lock level
(setq-default treesit-font-lock-level 4)

;; where to source the langs
(setq treesit-language-source-alist
  '((nix "https://github.com/nix-community/tree-sitter-nix")
    (c "https://github.com/tree-sitter/tree-sitter-c")
    (python "https://github.com/tree-sitter/tree-sitter-python")
    (javascript "https://github.com/tree-sitter/tree-sitter-javascript")
    (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
    (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
    (json "https://github.com/tree-sitter/tree-sitter-json")
    (toml "https://github.com/tree-sitter/tree-sitter-toml")
    (yaml "https://github.com/ikatyang/tree-sitter-yaml")
    (elixir "https://github.com/elixir-lang/tree-sitter-elixir")
    (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
    (rust "https://github.com/tree-sitter/tree-sitter-rust")
    ;; (html "https://github.com/tree-sitter/tree-sitter-html") ;not used yet cant find a good html-ts-mode and I dont feel like making one
    (css "https://github.com/tree-sitter/tree-sitter-css")
    (go "https://github.com/tree-sitter/tree-sitter-go")
    (java "https://github.com/tree-sitter/tree-sitter-java")
    (bash "https://github.com/tree-sitter/tree-sitter-bash")))

;; auto install any missing defined langs
(dolist (lang treesit-language-source-alist)
  (unless (treesit-language-available-p (car lang))
    (treesit-install-language-grammar (car lang))))

;; maps the ts modes to normal modes
(add-to-list 'major-mode-remap-alist '(c-mode . c-ts-mode))
(add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
(add-to-list 'major-mode-remap-alist '(sh-mode . bash-ts-mode))
(add-to-list 'major-mode-remap-alist '(css-mode . css-ts-mode))
(add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
(add-to-list 'major-mode-remap-alist '(javascript-mode . js-ts-mode))
(add-to-list 'major-mode-remap-alist '(java-mode . java-ts-mode))

;; for modes that have an existing ts mode but no existing normal mode
(add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
(add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-ts-mode))
(add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-ts-mode))
(add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
(add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))

;; If you need to override the names of the expected libraries, defualt emacs looks for libtree-sitter-${LANG_NAME}
;; (setq treesit-load-name-override-list
;;    '((cc "libtree-sitter-c")
;;      (bash "libtree-sitter-bash")))
#+end_src





